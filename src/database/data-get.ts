import { timeStampGen } from '../utils/global-helpers';
import { poolConn } from './conn';
import { PrLog, Project } from '../utils/types';
import { RowDataPacket } from 'mysql2';

type ParamsArr = string | number 

function queryBuilder(id: number, offset: number, pageSize: number, searchQuery: string, type: string, startDate: string, endDate: string): [string, string, ParamsArr[]] {
    let conditions = '';
    const params: ParamsArr[] = [id];

    if (searchQuery.trim().length > 0) {
        conditions += `(message LIKE ? OR location LIKE ? or code LIKE ?) AND `;
        params.push(`%${searchQuery}%`, `%${searchQuery}%`, `%${searchQuery}%`);
    }

    if (type.trim().length > 0) {
        conditions += `type = ? AND `;
        params.push(type);
    }

    if (startDate.trim().length > 0 && endDate.trim().length > 0) {
        conditions += `timestamp BETWEEN ? AND ? AND `;
        params.push(startDate, endDate);
    }

    const mainQuery = `
        SELECT 
            id, type, code, location, timestamp, message, project_id
        FROM 
            errors
        WHERE 
            project_id = ? 
            ${conditions ? 'AND ' + conditions.slice(0, -5) : ''}
        ORDER BY 
            timestamp DESC 
        LIMIT 
            ?, ?;
    `;

    const countQuery = `
        SELECT COUNT(id) as total 
        FROM errors 
        WHERE project_id = ? 
        ${conditions ? 'AND ' + conditions.slice(0, -5) : ''};
    `;

    return [mainQuery, countQuery,[...params, offset, pageSize,]];
}



export async function getProjects(): Promise<Project[] | [] | null> {
    const pool = await poolConn();
    if (!pool) {
        return null;
    }

    try {
        const [rows] = await pool.query<RowDataPacket[]>('SELECT id, name, description, github, image, enabled FROM projects ORDER BY updated_at DESC');
        if (rows.length <= 0) {
           return [];
        }

        const projects: Project[] = [];
        for (const row of rows) {
            projects.push({
                id: row.id,
                name: row.name,
                description: row.description,
                github: row.github,
                enabled: !!row.enabled,
                image: row.image
            });
        }

        return projects;
    } catch (error) {
        console.error(timeStampGen(), 'Error in @/database/data-get.ts generated by func getProjects details: ', error)
        return null;
    } finally {
        pool.release();
    };
};

export async function getProject(id: number): Promise<Project | null> {
    const pool = await poolConn();
    if (!pool) {
        return null;
    }

    try {
        const [rows] = await pool.query<RowDataPacket[]>('SELECT id, name, description, github, image, enabled, apiKey, updated_at FROM projects WHERE id = ? LIMIT 1', [id]);
        if (rows.length <= 0) {
            return null;
        }

        const row = rows[0];
        return {
            id: row.id,
            name: row.name,
            description: row.description,
            github: row.github,
            image: row.image,
            enabled: !!row.enabled,
            apiKey: row.apiKey,
            // convert the date to a format dd.mm.yyyy at hh:mm:ss
            updated_at: new Date(row.updated_at).toLocaleString('bg-BG', { timeZone: 'Europe/Sofia' })
        };
    } catch (error) {
        console.error(timeStampGen(), 'Error in @/database/data-get.ts generated by func getProject details: ', error)
        return null;
    } finally {
        pool.release();
    };
};

export async function getProjectLogs(id: number, offset: number, pageSize: number, searchQuery: string, type: string, startDate: string, endDate: string): Promise<PrLog | null> {
    const pool = await poolConn();
    if (!pool) {
        return null;
    }

    try {
        // check if the id exists in the database
        const [check] = await pool.query<RowDataPacket[]>('SELECT name FROM projects WHERE id = ? LIMIT 1', [id]);
        if (check.length <= 0) {
            return null;
        }

        const query = queryBuilder(id, offset, pageSize, searchQuery, type, startDate, endDate)

        const [rows] = await pool.query<RowDataPacket[]>(query[0] ,query[2]);
        const [total] = await pool.query<RowDataPacket[]>(query[1], query[2])
    
        if (rows.length <= 0) {
            return {
                logs: [],
                projectName: check[0].name,
                total: 0
            }
        }

        const logs: PrLog['logs'] = [];
        for (const row of rows) {
            logs.push({
                id: row.id,
                project_id: row.project_id,
                type: row.type,
                code: row.code,
                message: row.message,
                timestamp: new Date(row.timestamp).toLocaleString('bg-BG', { timeZone: 'Europe/Sofia' }),
                location: row.location
            });
        }

        return {
            logs: logs,
            projectName: check[0].name,
            total: total[0].total
        };
    } catch (error) {
        console.error(timeStampGen(), 'Error in @/database/data-get.ts generated by func getProjectLogs details: ', error)
        return null;
    } finally {
        pool.release();
    };
}